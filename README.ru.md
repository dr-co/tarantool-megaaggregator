# Аггрегатор

Для аггрегации с последующей обработкой можно использовать данный аггрегатор:


Настройка:

```lua
megaagg = require 'megaagg'
megaagg:init{
	-- время жизни тасков по умолчанию (сек)
        ttl         = 5 * 60,

	-- использовать персистентный или аггрегатор в памяти
        persistent  = false,

        -- Количество в аггрегаторе, которое надо превысить чтобы
        -- аггрегатор начал проталкивать данные далее
        limit       = 150,

        -- Интервал аггрегации
        timeout     = 1.5,
}
```

Продюсеры:

```lua
megaagg:push('abc', { 123, 345 })
megaagg:push('cde', { 234, 234 })

megaagg:push_list('abc', { { 123, 345 }, { 234, 234 } })

```

Консюмер аггрегатора `abc`:

```lua

while true
	local list = megaagg:take('abc', 200, 0.1)
	if list then
		for _, task in pairs(list) do
			process_task(task)
		end
	end
end
```

Аггрегатор может хранить данные в персистентном хранилище, так и в
незаписываемом на диск.

Определить вид хранилища можно опцией `persistent` при инициализации, либо
опцией для каждого таска индивидуально:

```lua
megaagg:push('abc', { 123, 345 }, { persistent = true })
megaagg:push('cde', { 234, 234 }, { persistent = false })

megaagg:push_list('abc',
	 { { 123, 345 }, { 234, 234 } },
	 { persistent = true }
)

```

Таким же образом можно определить время жизни (`ttl`) таска.

Обратите внимание: если устанавливать `ttl` таска меньше чем интервал
аггрегации, то возможно Ваши таски никогда не дойдут до консьюмера.


## Хранилище

Каждая очередь размещается в двух хранилищах сразу.
Таски выдаются в том порядке в котором поступили.

Если первую таску положить в `persistent` хранилище, вторую в `in-memory`,
а затем попросить аггрегатор выдать две таски, то будут выданы обе.

Если перед тем как попросить аггрегатор выдать две таски перезапустить
систему, то таска в `in-memory` хранилище будет потеряна.
